#ps/Sieve-of-Eratosthenes

# [소수 구하기](https://www.acmicpc.net/problem/1929)
- 이전에 python으로 2번 정도 푼 적이 있어 여유롭게 풀었다가 틀렸다. 돌이켜보면 그 때도 완전 탐색을 시도했던거 같다. 이 참에 에라토스테네스의 체에 대해 확실하게 알고 가자!

## 직접 판별 vs 에라토스테네스의 체
- 직접 판별(한 번에 하나씩 체크): N이 커질수록 급격하게 느려짐 → 비추!
- 에라토스테네스의 체: N+1 만큼 배열을 만들어, 소수의 배수는 한 번에 지운다 → 한 번 확인한 수는 다시 확인하지 않는다 >> 매우 빠름!
```java
// M = 3, N = 16
boolean[] isNotPrime = new boolean[N + 1]; // 0 ~ N
isNotPrime[0] = true; // 0은 소수가 아니다
isNotPrime[1] = true; // 1은 소수가 아니다

for (int i = 2; i * i <= N; i++) {
	// 이미 true로 판명된 수는 다시 검사하지 않는다
	if (!isNotPrime[i]) {
		// j는 i의 배수 >> 소수가 아닌 수를 체크한다
		for (int j = i * i; j <= N; j += i) {
			isNotPrime[j] = true;
		}
	}
}

for (int i = M; i <= N; i++) {
	if (!isNotPrime[i]) {
		bw.write(i + "\n"); // BufferedWriter 사용
	}
}

bw.flush();
bw.close();

```
## `Math.sqrt()` 대신 `i * i`를 사용하는 이유는?
- `Math.sqrt()`는 매 loop마다 제곱근 계산을 하므로 미세하게 느림 → `i * i` 를 사용하자!