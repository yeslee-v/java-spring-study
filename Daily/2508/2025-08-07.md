#project 
# IntelliJ에서 코드 변경 자동 감지해 재실행
1. build.gradle에 spring-boot-devtools 추가
```java
// 개발에서만 사용하므로 developmentOnly
developmentOnly 'org.springframework.boot:spring-boot-devtools'
```
2. Setting 접속
	1. build project automatically 체크
3. Allow auto-make to start even if developed application is currently running 체크**

# 잘 되던 테스트가 갑자기 안되는 이유는?
- 파일 기반 H2 데이터베이스를 사용할 때는 서버와 테스트가 동일한 데이터베이스 파일에 동시 접근하면 충돌 발생 → 서버 종료한 상태에서 테스트 실행해야

  원인 분석:
  - 파일 기반 H2 데이터베이스(jdbc:h2:file:~/recareer-test-db)는 동시에 여러 프로세스에서 접근할 수 없습니다
  - 서버가 실행 중일 때 테스트를 동시에 실행하면 데이터베이스 락 충돌이 발생합니다
  - H2 MVStore 예외가 이를 나타내는 전형적인 증상입니다

  해결 방법:
  1. 현재 방법: 서버를 종료한 후 테스트 실행 (지금 사용한 방법)
  2. 대안 1: 테스트용으로 다른 데이터베이스 파일 사용
  3. 대안 2: 테스트 시에만 메모리 기반 H2 사용

# controller test vs service test
  MentorController 통합 테스트로 데이터베이스 확인

  테스트코드를 통해서도 API 엔드포인트가 데이터베이스에 제대로 데이터를 저장하는지 확인할 수 있습니다!

  작성한 통합 테스트의 특징:
  1. 실제 HTTP 요청 시뮬레이션: MockMvc를 사용해서 실제 API 호출과 동일한 테스트
  2. 데이터베이스 검증: API 호출 후 Repository를 통해 실제 DB에 저장되었는지 확인
  3. 응답 검증: JSON 응답 형식과 메시지 확인

  핵심 테스트 예시:
  @Test
  @DisplayName("멘토 정보 수정 API 테스트 - 데이터베이스 확인")
  void updateMentor_Success_CheckDatabase() throws Exception {
      // API 호출
      mockMvc.perform(put("/mentors/{id}", mentor.getId())
              .param("position", newPosition)
              .param("description", newDescription))
              .andExpect(status().isOk());

      // 실제 데이터베이스에 저장되었는지 확인
      Mentor updatedMentor = mentorRepository.findById(mentor.getId()).orElse(null);
      assertThat(updatedMentor.getPosition()).isEqualTo(newPosition);
  }

  장점:
  - Postman 없이도 모든 엔드포인트의 데이터베이스 저장 확인 가능
  - 자동화된 테스트로 CI/CD 파이프라인에서 실행 가능
  - 코드 변경 시마다 자동으로 검증

  이제 API가 데이터베이스에 제대로 저장하는지 테스트코드로 확인할 수 있습니다!

> 그럼 controller test랑 service test랑 차이가 뭐야?

⏺ 좋은 질문입니다! 두 테스트의 차이점을 설명해드리겠습니다.

  Service Test vs Controller Test

  Service Test (MentorServiceTest)

  @SpringBootTest
  @ActiveProfiles("dev")
  @Transactional  // 롤백됨
  class MentorServiceTest {

      @Test
      void updateMentor_Success() {
          // 직접 서비스 메서드 호출
          Optional<Mentor> result = mentorService.updateMentor(id, position, description);

          // 비즈니스 로직만 검증
          assertThat(result.get().getPosition()).isEqualTo(newPosition);
      }
  }

  특징:
  - ✅ 비즈니스 로직만 테스트 (서비스 레이어)
  - ✅ 단위 테스트 성격 (빠름)
  - ✅ @Transactional로 롤백됨 (DB에 데이터 남지 않음)
  - ❌ HTTP 요청/응답, JSON 변환 등은 테스트 안됨

  Controller Test (MentorControllerTest)

  @SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
  @ActiveProfiles("dev")
  @Transactional  // 롤백됨
  class MentorControllerTest {

      @Test
      void updateMentor_Success_CheckDatabase() throws Exception {
          // 실제 HTTP 요청 시뮬레이션
          mockMvc.perform(put("/mentors/{id}", mentor.getId())
                  .param("position", newPosition))
                  .andExpect(status().isOk())
                  .andExpect(jsonPath("$.message").value("성공 메시지"));

          // DB에 실제 저장되었는지 확인
          Mentor updatedMentor = mentorRepository.findById(id).orElse(null);
          assertThat(updatedMentor.getPosition()).isEqualTo(newPosition);
      }
  }

  특징:
  - ✅ 전체 요청 플로우 테스트 (HTTP → Controller → Service → Repository → DB)
  - ✅ 통합 테스트 성격 (실제 운영 환경과 유사)
  - ✅ HTTP 상태코드, JSON 응답, ApiResponse 형식 등 모두 검증
  - ✅ 실제 데이터베이스 저장까지 확인
  - ❌ 상대적으로 느림

  비교표

  | 구분           | Service Test | Controller Test   |
  |--------------|--------------|-------------------|
  | 테스트 범위       | 비즈니스 로직만     | HTTP → DB 전체 플로우  |
  | 테스트 레벨       | 단위 테스트       | 통합 테스트            |
  | HTTP 검증      | ❌            | ✅ (상태코드, JSON 응답) |
  | DB 저장 확인     | ❌ (롤백됨)      | ✅                 |
  | 속도           | 빠름           | 상대적으로 느림          |
  | 실제 운영 환경 유사도 | 낮음           | 높음                |

  언제 무엇을 사용할까?

  Service Test 사용:
  - 비즈니스 로직의 정확성 검증
  - 빠른 피드백이 필요한 TDD
  - 복잡한 계산이나 조건문 테스트

  Controller Test 사용:
  - API 엔드포인트의 전체적인 동작 검증
  - 실제 데이터베이스 저장 확인 필요
  - HTTP 응답 형식, 에러 처리 검증

  둘 다 작성하는 것이 이상적이며, 서로 다른 관점에서 코드의 품질을 보장합니다!
