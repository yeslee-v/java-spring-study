그럼 네 “알고리즘 문제 패턴 노트” 포맷에 맞춰서 정리해줄게.

---

# **1. 유형**

  

그리디(케이스 분류) / 규칙 도출 문제

---

# **2. 접근 흐름**

1. 문제 분석:
    
    - 병든 나이트는 4가지 이동 패턴만 사용 가능.
        
    - 5칸 이상 방문하려면 4가지 패턴을 모두 써야 한다는 제약 존재.
        
    - 세로 크기(N)와 가로 크기(M)에 따라 최대 방문 칸 수가 O(1)로 결정됨.
        
    
2. 알고리즘 선택 이유:
    
    - BFS/DFS로 전수 탐색하면 불필요하고 비효율적.
        
    - 단순 규칙 분석 + 경우 분리로 계산 가능.
        
    
3. 핵심 아이디어:
    
    - N == 1: 이동 불가 → 시작 칸 1개
        
    - N == 2: 수직 이동 한정 → 최대 4칸 제한, (M+1)/2로 계산
        
    - N >= 3:
        
        - M <= 6: 최대 4칸 제한 → min(4, M)
            
        - M >= 7: 초반 2칸은 이동 패턴 채우는 데 사용 → M - 2
            
        
    

---

# **3. 핵심 코드 (3~5줄)**

```
if (N == 1) ans = 1;
else if (N == 2) ans = Math.min(4, (M + 1) / 2);
else {
    if (M <= 6) ans = Math.min(4, M);
    else ans = M - 2;
}
```

---

# **4. 주의 포인트**

- 예외 케이스:
    
    - M=1이면 무조건 1
        
    - N=2일 때 (M+1)/2 계산 시 올림이 아니라 int 나눗셈이므로 (M+1)/2 그대로 사용
        
    
- 자료형 주의:
    
    - int로 충분 (N, M이 int 범위 안)
        
    
- 내가 실수한 부분:
    
    - BFS로 접근 → 불필요한 전수 탐색 시도
        
    - 규칙 도출이 가능한 문제를 탐색으로 푸는 버릇
        
    - 경우 분류 순서(N==1, N==2, N>=3) 없이 한 번에 처리하려다 꼬임
        
    

---

이렇게 메모해두면 다음에 비슷한 “말 이동 + 제약” 문제 나올 때 공식은 바로 떠올리고,

이유는 2~3번 풀면서 체득 가능할 거야.

  

원하면 내가 이 문제랑 비슷한 유형 예시도 2~3개 같이 추천해줄 수 있다.

그렇게 해줄까?