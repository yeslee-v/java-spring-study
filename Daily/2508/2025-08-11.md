#ps/string 
# [JadenCase 문자열 만들기](https://school.programmers.co.kr/learn/courses/30/lessons/12951?language=java#)

> 핵심: 조건부(공백 유무) → flag 사용하자!
> 어설프게 `i + 1` 같이 사용했다가 인덱스 관리 까다로워짐

## 1. 유형
- 문자열(String) 처리 → 구분자 기반 단어 변환 → 대소문자 규칙 적용
## 2. 접근 흐름

1. 문제 분석:
    
    - 문자열의 각 문자를 순회하며 “단어의 첫 글자만 대문자, 나머지는 소문자” 규칙 적용.
    - 공백은 그대로 보존, 연속 공백/선행·후행 공백 허용. 숫자/특수문자 등장 가능.
    
2. 알고리즘 선택 이유:
    
    - 한 번의 선형 스캔(O(N))으로 상태 플래그(startOfWord)만 관리하면 모든 요구사항 충족.
    - i+1 같은 룩어헤드가 필요 없어 경계 오류 감소.
    
3. 핵심 아이디어
    
    - 상태 머신 1비트: 직전 문자가 공백이면 startOfWord = true.
        
    - 현재 문자가 알파벳이면 startOfWord ? upper : lower 적용, 공백은 그대로 추가.
        
    - 처리 후 `startOfWord = (c == ' ')`로 갱신.
## 3. 핵심 코드(3~5줄)

```java
StringBuilder sb = new StringBuilder(s.length());
boolean start = true;

for (int i = 0; i < s.length(); i++) {
    char c = s.charAt(i);

		sb.append(start ? Character.toUpperCase(c) : Character.toLowerCase(c));
    
    start = (c == ' ');
}
```

## 4. 주의 포인트

- 예외 케이스:    
    - 빈 문자열 ""
    - 선행/후행/연속 공백 " for  the last  week "
    - 숫자/특수문자 포함 "3people unFollowed me", "a-b" (구분자는 문제 정의에 따라 다름)
    - 전부 대문자/소문자 "ABC", "abc"

- 자료형 주의:

    - Character.toUpperCase/LowerCase 사용(직접 ‘a’~‘z’ 비교보다 안정적).        
    - StringBuilder 용량 사전 확보(new StringBuilder(s.length()))로 미세 최적화.
            
- 내가 실수한 부분:
    
    - i+1 룩어헤드로 인덱스 범위 초과 가능성.
    - 분기별로 i 증가 누락 → 무한 루프.
    - 단어 첫 글자만 처리하고 “나머지 소문자화” 누락.
    - 숫자로 시작하는 단어에서 이후 문자를 소문자화하지 않음.