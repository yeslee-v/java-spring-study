#ps/bfs-dfs

# [2468. 안전 영역](https://www.acmicpc.net/problem/2468)
- 문제만 읽었을 때는 이해가 잘 안가서 예시보고 직접 그려보면서 문제의 의도를 이해했다.
	- 강수량이 증가하면서 잠기지 않는 안전 영역의 개수 중 최대 개수를 구하라!! → 모든 안전영역의 개수를 구해야함
- 예전에 비슷한 문제를 풀어봤던거 같은데 기억이 안났다. 일단 초기 구현 계획은..
	1. isVisit 2차원 배열을 만들고
	2. 이중 for문으로 입력값을 받으면서 N보다 작으면 해당 isVisit 값을 true로 바꾼다
		1. 입력받은 map 값을 저장해야겠다는 생각을 못함…!
		2. 그리고 강수량 기준으로 비교하려고 했음.. → isVisit의 의도는 해당 좌표를 이미 방문했는지 여부를 기록하는거임..
	3. 상하좌우를 비교한다..
- 비교해서 인접 값을 찾아? 영역을 만든다??????? ← 막히게 된 결정적인 원인……..
- 이전에 BFS 문제를 풀었던게 생각나 해당 문제를 다시 풀고 왔더니, 재귀로 풀면 되겠다 싶었으나
- 그래서 어떻게 접근해야하는거지???????? 싶어서 결국 gpt한테 지금 제대로 접근하고있는게 맞는지 물어봄..

## 해결 접근 방법..
1. 입력받는 로직부터 그러니까 자바 문법부터 틀렸다;; → 백준풀다가 leetcode로 풀다보나 `BufferedReader` 류의 io 메서드를 그새 까먹었던 것.. 
2. 재귀는 맞다 → dfs는 재귀로 bfs는 queue를 이용해서 푼다 » dfs가 bfs보다 빠르지만..
	1. N의 숫자가 크면 bfs가 유리하다 → dfs는 nullPointerException 위험이 있음
	2. 최단거리, 단계별 탐색 + 실무에서는 bfs를 좀 더 사용한다
	3. 결론: **두 방법으로 전부 풀 줄 알아야 한다**
3. 재귀를 돌기 위해서는 main외의 메서드를 선언해서 사용해야하므로 두 메서드에서 공통적으로 사용하는 변수는 static으로 main 메서드 외부에 정의한다
4. dx, dy라는 길이가 4인 int형 배열을 선언해 상하좌우를 검사한다 → 어디를 먼저 검사하라는 말이 없다면 시계방형으로 내 맘대로 해도 된다
5. dfs 메서드 내에서 반복문을 4번 돌면서 dx, dy 인자 값을 해당 좌표에 더해서..
		1. 더한 최종 좌표가 지도 범위를 벗어나거나, 이미 true면 건너뛴다
		2. 더한 좌표의 값이 현 height(0~N 사이의 값)보다 크면 dfs 재귀 → 안전 영역 없을 때까지!
6. ‘안전영역이 가장 많이 나오는 곳을 찾아라’가 문제의 본질이니, 안전 영역의 개수는 계속 업데이트된다 → `Math.max` 메서드를 활용한다
7. 그러면 N이 안전영역의 개수가 되는게 아닌가? 라는 의문을 가질 수 있다 → 결론적으로 NOPE!!
	1. 모든 지역의 높이가 다 다르기 때문에, 각 height마다 물에 잠기는 영역이 다르고,
	2. height가 0일 땐 전부 안전할 수도 있지만, height가 2일 때는 분리된 덩어리로 쪼개질 수도 있음
		1. 각 height가 전부 N보다 작으면 안전 영역 자체가 존재하지 않을 수도 있음
	3. 따라서 가장 많은 영역이 나오는 height는 보장되지 않으며, 직접 모두 탐색해야 함