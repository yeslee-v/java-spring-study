#ps/bfs-dfs #project 
# 1. 문제

```
N×M 크기의 미로가 주어집니다. 미로에서 1은 이동할 수 있는 칸을 나타내고, 0은 이동할 수 없는 벽을 나타냅니다.
당신은 (0, 0) 위치에서 출발하여 (N-1, M-1) 위치에 있는 출구로 이동하려고 합니다. 이동할 때는 상하좌우로 인접한 칸으로만 이동할 수 있습니다.
출발점에서 출구까지 가는 최단 경로의 길이를 구하세요. 만약 출구에 도달할 수 없다면 -1을 반환하세요.

입력
- 첫 번째 줄: N, M (2 ≤ N, M ≤ 100)
- 다음 N개의 줄: M개의 숫자로 이루어진 미로 정보

출력
- 최단 경로의 길이 (시작점과 도착점 포함)
- 도달할 수 없으면 -1

예시.

입력:
4 6
1 0 1 1 1 1
1 0 1 0 1 0
1 0 1 0 1 1
1 1 1 0 1 1
출력: 15

입력:
3 3
1 0 0
0 0 0
0 0 1
출력: -1
```

# 1. 유형

- bfs: 무가중치 격자 최단 경로 구하기

# 2. 접근 흐름

## 문제 분석

 - 입력: n*m 격자, 1은 통로, 0은 벽
 - 시작: (0, 0) / 도착: (n - 1, m - 1)
 - 이동: 상하좌우 인접 칸
 - 출력: 방문 칸 수 기준의 최단 경로 길이(도달 불가 시 -1)

## 알고리즘 선택 이유
 - 무가중치 최단 거리 = BFS
 - DFS: 모든 경로 탐색, 최소값 갱신하므로 비효율적

## 핵심 아이디어
- 한 번 지나간 길은 다시 가지 않으므로 map과 동일한 크기의 dist 2차원 배열 선언하여 순회한다

# 3. 핵심 코드(3~5줄)

```java
Queue<int[]> q = new ArrayDeque<>();
dist[0][0] = 1;
q.offer(new int[]{0,0});

while (!q.isEmpty()) {
  int[] cur = q.poll();
  for (int k=0;k<4;k++) {
    cur[0]+dr[k], cur[1]+dc[k]); // 유효성 검사
  }
}
```

## 4. 주의 포인트

### 예외 케이스

- 시작이나 도착이 벽(0) → 바로 -1
- 단일 칸(1×1) → 시작이 1이면 1, 아니면 -1
- 도달 불가(큐 소진) → -1

### 자료형 주의

- int형이 n, m 범위 커버

### 내가 실수한 부분(정리)
- 최단거리에 DFS 선택: n, m의 범위가 작아 dfs로 풀 수 있겠다고 판단(사실 queue쓰는거보다 재귀가 좀 더 편한 것도 있음)했지만, 최단거리 문제에서는 dfs 사용할 수 없다
- 방문처리를 boolean형 visited로 하고 거리 저장 안함 → dist를 방문표시 겸용

---

# 요청한 사용자 검증 비교
## 1. JWT token 조회

```java
// JWT 토큰에서 providerId 추출 → DB 조회로 userId 획득
String providerId = jwtTokenProvider.getProviderIdFromToken(token);
Long userId = userService.findByProviderId(providerId).getId();
```
 
## 2. 클라이언트에서 userId 직접 전송
```java
// 클라이언트에서 userId를 직접 받아서 JWT 토큰의 사용자와 일치하는지 확인
@PostMapping("/{reservationId}/mentee-feedback")
public ResponseEntity addMenteeFeedback(
		@RequestHeader("Authorization") String accessToken,
		@RequestParam Long userId,  // 클라이언트에서 전송
		@PathVariable Long reservationId) {

		// JWT 토큰의 사용자 ID와 요청한 userId가 일치하는지 확인
		if (!isTokenOwner(accessToken, userId)) {
				return ResponseEntity.forbidden();
		}
}
```
 
## 실무에서의 주로 사용하는 패턴: JWT token 조회 
### 보안 관점
- 신뢰할 수 있는 데이터 소스: JWT 토큰은 서버에서 서명된 신뢰할 수 있는 데이터
- 클라이언트 조작 방지: 클라이언트가 userId를 조작할 가능성 차단
- 단일 진실의 소스: JWT 토큰 하나만 검증하면 됨

### 성능 관점  
- 추가 DB 조회: 현재 방식은 DB 조회가 1번 더 필요하지만, 보안 이익이 더 큼
- 캐싱 가능: providerId → User 매핑은 캐싱하기 좋음

## 실무 예시
```java
// 일반적인 REST API 패턴
@GetMapping("/users/me")  // 현재 로그인한 사용자 정보
@PostMapping("/posts")    // 작성자는 JWT에서 자동 추출
@DeleteMapping("/posts/{id}")  // 소유자 권한은 JWT로 확인
```

## 결론
- 누가 요청했는가?:  클라이언트가 아닌 서버가 JWT 토큰을 통해 결정하는 것이 보안상 더 안전하다