#ps/bfs-dfs 
# 1. 문제

```
N×M 크기의 미로가 주어집니다. 미로에서 1은 이동할 수 있는 칸을 나타내고, 0은 이동할 수 없는 벽을 나타냅니다.
당신은 (0, 0) 위치에서 출발하여 (N-1, M-1) 위치에 있는 출구로 이동하려고 합니다. 이동할 때는 상하좌우로 인접한 칸으로만 이동할 수 있습니다.
출발점에서 출구까지 가는 최단 경로의 길이를 구하세요. 만약 출구에 도달할 수 없다면 -1을 반환하세요.

입력
- 첫 번째 줄: N, M (2 ≤ N, M ≤ 100)
- 다음 N개의 줄: M개의 숫자로 이루어진 미로 정보

출력
- 최단 경로의 길이 (시작점과 도착점 포함)
- 도달할 수 없으면 -1

예시.

입력:
4 6
1 0 1 1 1 1
1 0 1 0 1 0
1 0 1 0 1 1
1 1 1 0 1 1
출력: 15

입력:
3 3
1 0 0
0 0 0
0 0 1
출력: -1
```

# 1. 유형

- bfs: 무가중치 격자 최단 경로 구하기

# 2. 접근 흐름

## 문제 분석

 - 입력: n*m 격자, 1은 통로, 0은 벽
 - 시작: (0, 0) / 도착: (n - 1, m - 1)
 - 이동: 상하좌우 인접 칸
 - 출력: 방문 칸 수 기준의 최단 경로 길이(도달 불가 시 -1)

## 알고리즘 선택 이유
 - 무가중치 최단 거리 = BFS
 - DFS: 모든 경로 탐색, 최소값 갱신하므로 비효율적

## 핵심 아이디어
- 한 번 지나간 길은 다시 가지 않으므로 map과 동일한 크기의 dist 2차원 배열 선언하여 순회한다

# 3. 핵심 코드(3~5줄)

```java
Queue<int[]> q = new ArrayDeque<>();
dist[0][0] = 1;
q.offer(new int[]{0,0});

while (!q.isEmpty()) {
  int[] cur = q.poll();
  for (int k=0;k<4;k++) {
    cur[0]+dr[k], cur[1]+dc[k]); // 유효성 검사
  }
}
```

## 4. 주의 포인트

### 예외 케이스

- 시작이나 도착이 벽(0) → 바로 -1
- 단일 칸(1×1) → 시작이 1이면 1, 아니면 -1
- 도달 불가(큐 소진) → -1

### 자료형 주의

- int형이 n, m 범위 커버

### 내가 실수한 부분(정리)
- 최단거리에 DFS 선택: n, m의 범위가 작아 dfs로 풀 수 있겠다고 판단(사실 queue쓰는거보다 재귀가 좀 더 편한 것도 있음)했지만, 최단거리 문제에서는 dfs 사용할 수 없다
- 방문처리를 boolean형 visited로 하고 거리 저장 안함 → dist를 방문표시 겸용