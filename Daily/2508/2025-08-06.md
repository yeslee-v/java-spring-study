#ps/greedy 
# 지난 문제 다시 풀어보기
## 안전 영역
- dfs: 문법 오류와 함께 조금은 기억나지만
- bfs: 기억도 안난다;; → Queue 쓰는 이유: BFS는 row 대로 확인하기 때문에 FIFO 사용해야

## 소수 구하기
- io 패키지 불러오면 `throws IOExeption`  염두해두어야!
- 항상 철자 신경쓰자.. 철자..

---
# [2437. 저울](acmicpc.net/problem/2437)
- isWeight boolean 배열 생성해 조합 가능한 모든 경우를 다 세려고 했음 → 만들 수 없는 최소값이 뭔지?
- 선 정렬 - 누적합으로 판단 → 전형적인 그리디 문제
	- 그리디 알고리즘 자체를 잘 몰랐음..
	- 탐색 문제(완전 탐색 불가) + 최소값/최대값 → 그리디 문제!!

```java
import java.io.*;
import java.util.*;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        
        int n = Integer.parseInt(br.readLine());
        int[] weights = new int[n]; // 추의 무게 저장할 배열
        
        StringTokenizer st = new StringTokenizer(br.readLine());
        for (int i = 0; i < n; i++) {
            weights[i] = Integer.parseInt(st.nextToken());
        }
        
        Arrays.sort(weights); // 오름차순 정렬: 작은 값부터 누적합 계산
        
        int target = 1; // 만들 수 없는 최소 무게 초기값: 1부터 시작
        for (int w: weights) {
            if (target < w) break; // 만들 수 없는 최소값인 target보다 큰 w가 나오면 끝
            
            // 1 ~ target 사이의 값 생성 가능
            // w 더해서 target ~ target + w - 1까지 생성 가능
            target += w;
        }
        
        System.out.println(target);
    }
}
```