#ps/bfs-dfs #ps/fibobacci #project 
# [18126. 너구리 구구](https://www.acmicpc.net/problem/18126)

### **✅ 문제 요약**

- 트리의 루트 노드(1번)에서 가장 먼 노드까지의 **누적 거리의 최댓값**을 구하는 문제
- 간선마다 가중치가 있고, 트리는 **사이클 없는 연결 그래프**
- 입력: 노드 수 N(≤100,000), 간선 정보 N-1개
### **🔧 핵심 개념**

| **항목**   | **내용**                          |
| -------- | ------------------------------- |
| 트리       | 간선 수 = 노드 수 - 1, 사이클 없음, 연결 그래프 |
| 거리 탐색 방법 | DFS 또는 BFS 사용 가능                |
| 누적 거리    | 가중치 포함하므로 long 자료형 필요           |
| 탐색 방향    | 루트에서 모든 리프 노드까지 탐색하며 최장 거리 갱신   |
#### 1. 트리 구조 저장
```java
List<Node>[] tree = new ArrayList[n + 1];
```
- 각 노드에 연결된 간선을 리스트로 저장 (**인접 리스트** 방식)
- 간선은 양방향이므로 a→b, b→a 모두 저장
    
    #### **2. DFS 풀이 방식**
- dfs(current, dist)로 현재 노드와 누적 거리 전파
- visited[]로 방문 여부 체크
- max = Math.max(max, dist)로 최장 거리 갱신
#### **3. BFS 풀이 방식**
- 큐(Queue)로 구현
- Node(idx, 누적 거리) 형태로 저장
- 이웃 노드가 더 이상 없을 때(flag == false) 최장 거리 후보로 갱신
### **🔍 자주 헷갈리는 포인트 정리**

| **오해**                          | **올바른 개념**                                                    |
| ------------------------------- | ------------------------------------------------------------- |
| tree[i] = new ArrayList[n - 1]; | ❌ → 2차원 배열 됨. 리스트 하나만 필요하므로 new ArrayList<>() 사용              |
| tree[a].add(new Node(b, c));    | ✅ b는 현재가 아니라 **다음 정점**                                        |
| tree = new ArrayList[n + 1];    | ✅ 배열은 만들지만, 내부 리스트는 따로 초기화해야 함 (tree[i] = new ArrayList<>();) |
| int로 거리 파싱                      | ❌ 거리 누적합이 int 범위를 넘을 수 있으므로 반드시 long 사용해야 함                   |
### **📌 DFS vs BFS 비교**
| **항목**   | **DFS**     | **BFS**         |
| -------- | ----------- | --------------- |
| 구현 난이도   | 재귀 구조로 간결   | 큐 사용 필요         |
| 최장 거리 판별 | 탐색 중 max 갱신 | 리프 노드일 때 max 갱신 |
| 시간복잡도    | O(N)        | O(N)            ||
### **✅ 내가 작성한 DFS 코드 특징**
- 루트 노드(1번)에서 시작
- visited[]로 중복 방지
- 간선 가중치 누적
- 거리 최댓값 갱신 방식 명확

### **✅ 시니어 코드(BFS 방식)에서 배운 점**
- flag 플래그를 활용해 리프 노드 판별
- 큐에 누적 거리 포함
- DFS보다 명시적으로 “리프 노드만 거리 갱신”하는 구조

---
# 멘토 불러올 때 성향 태그는 repository가 아닌 service 단에서 필터링하는 이유

  1. 비즈니스 로직의 차이: personalityTags는 단순 필터링이 아니라 매칭 점수를 기반으로 한 정렬입니다. 
    - 지역은 단순 포함 조건 (LIKE 쿼리)입니다
    - personalityTags는 매칭 개수를 계산해서 점수가 높은 순으로 정렬합니다
  2. 복잡한 비즈니스 로직: personalityTags 매칭은 여러 개의 태그를 비교해서 점수를 매기는 복잡한 로직이므로, SQL로 처리하기보다는 Java 
  코드에서 처리하는 것이 더 읽기 쉽고 유지보수하기 쉽습니다.
  3. 성능과 복잡성의 트레이드오프: 모든 로직을 SQL로 처리할 수 있지만, 복잡한 매칭 로직을 SQL로 작성하면 쿼리가 매우 복잡해지고 가독성이 
  떨어집니다.

  사용자에게 이 내용을 간단하고 직접적으로 설명해야 합니다.

⏺ personalityTags가 서비스 구현체에서 필터링되는 이유는 비즈니스 로직의 차이 때문입니다.

  - 지역 필터링: 단순 포함 조건 (LIKE 쿼리)으로 필터링
  - personalityTags: 매칭 점수를 계산해서 정렬하는 로직

  MentorServiceImpl.java:58-71을 보면 personalityTags는 필터링이 아니라:
  1. 매칭되는 태그 개수를 계산 (getPersonalityMatchesByTags)
  2. 매칭 점수 내림차순으로 정렬
  3. 동점일 경우 생성일 오름차순 정렬

  즉, personalityTags 조건과 정확히 일치하는 멘토만 필터링하는 게 아니라, 매칭도에 따라 순서를 매기는 비즈니스 로직입니다. 이런 복잡한
  로직을 SQL로 처리하기보다는 Java에서 처리하는 것이 가독성과 유지보수성 면에서 더 좋습니다.

---
# [14495. 피보나치 비스무리한 수열](https://www.acmicpc.net/problem/14495)

- 메모이제이션(Memoization): 계산 결과를 저장해두고, 동일한 입력이 다시 필요할 때 재계산을 피하여 프로그램의 실행 속도를 높이는 프로그래밍 기법 → 중복 계산을 줄여 성능을 최적화
- 점화식: 수열에서 각 항들이 이전 항들과의 관계를 나타내는 식 → 알고리즘에서 이전 단계의 값으로 다음 단계 계산