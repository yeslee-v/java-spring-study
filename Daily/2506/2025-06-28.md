---
sticker: lucide//fast-forward
---
# Insert Delete GetRandom O(1)
## 1차 작성
- 테스트 자체는 통과했으나 시간복잡도 O(n)
- ***You must implement the functions of the class such that each function works in average `O(1)` time complexity. → 미충족***

```java
import java.util.*;

class RandomizedSet {
	private Set<Integer> set;

	public RandomizedSet() {
		set = new HashSet<>();
	}

	public boolean insert(int val) {
		if (set.contains(val)) {
			return false;
		}

		set.add(val);
		
		return true;
	}

	public boolean remove(int val) {
		if (set.contains(val)) {
			set.remove(val);
			
			return true;
		}
		
			return false;
	}
	
	public int getRandom() {
		if (set.isEmpty()) {
			return 0;
		}
		
		List<Integer> list = new ArrayList<>(set); // O(n)	
		Random random = new Random();
		
		return list.get(random.nextInt(list.size()));
	}
}

  

/**

* Your RandomizedSet object will be instantiated and called as such:

* RandomizedSet obj = new RandomizedSet();

* boolean param_1 = obj.insert(val);

* boolean param_2 = obj.remove(val);

* int param_3 = obj.getRandom();

*/
```
- ArrayList 선언 이유: map, set은 순서가 없어 인덱스로 접근 불가한 해시 테이블 → 랜덤으로 순회 불가
- *`getRandom` 메서드 호출할 때마다 HashSet 모든 요소를 `arrayList`로 복사 → O(n)*

## 2차 수정
- set 생성할 때 arrayList와 random을 같이 생성한다.
- RandomizedSet 메서드: HashSet 대신 HashMap으로 선언해야한다
	- set: 값의 포함 여부(`contains()`)는 알 수 있지만 인덱스는 모름 → 전체 순회 필요
	- map: 값의 인덱스까지 같이 저장 → 바로 알 수 있다
- remove 메서드
	- arrayList에서 값 삭제: 인덱스를 알아야한다 → map에 저장된 인덱스 활용 → O(1)
	- arrayList에서 중간에 있는 값 삭제: 뒤에 있는 값들 한 칸 씩 앞으로 당겨야 함 → O(n)
		- 마지막 요소를 삭제한 값 위치로 복사