---
sticker: lucide//fast-forward
---
# Insert Delete GetRandom O(1)
## 1차 작성
- 테스트 자체는 통과했으나 시간복잡도 O(n)
- ***You must implement the functions of the class such that each function works in average `O(1)` time complexity. → 미충족***

```java
import java.util.*;

class RandomizedSet {
	private Set<Integer> set;

	public RandomizedSet() {
		set = new HashSet<>();
	}

	public boolean insert(int val) {
		if (set.contains(val)) {
			return false;
		}

		set.add(val);
		
		return true;
	}

	public boolean remove(int val) {
		if (set.contains(val)) {
			set.remove(val);
			
			return true;
		}
		
			return false;
	}
	
	public int getRandom() {
		if (set.isEmpty()) {
			return 0;
		}
		
		List<Integer> list = new ArrayList<>(set); // O(n)	
		Random random = new Random();
		
		return list.get(random.nextInt(list.size()));
	}
}

  

/**

* Your RandomizedSet object will be instantiated and called as such:

* RandomizedSet obj = new RandomizedSet();

* boolean param_1 = obj.insert(val);

* boolean param_2 = obj.remove(val);

* int param_3 = obj.getRandom();

*/
```
- ArrayList 선언 이유: map, set은 순서가 없어 인덱스로 접근 불가한 해시 테이블 → 랜덤으로 순회 불가
- *`getRandom` 메서드 호출할 때마다 HashSet 모든 요소를 `arrayList`로 복사 → O(n)*

## 2차 수정
- set 생성할 때 arrayList와 random을 같이 생성한다.
- RandomizedSet 메서드: HashSet 대신 HashMap으로 선언해야한다
	- set: 값의 포함 여부(`contains()`)는 알 수 있지만 인덱스는 모름 → 전체 순회 필요
	- map: 값의 인덱스까지 같이 저장 → 바로 알 수 있다
- remove 메서드
	- arrayList에서 값 삭제: 인덱스를 알아야한다 → map에 저장된 인덱스 활용 → O(1)
	- arrayList에서 중간에 있는 값 삭제: 뒤에 있는 값들 한 칸 씩 앞으로 당겨야 함 → O(n)
		- 마지막 요소를 삭제한 값 위치로 복사

---

# print bean
- ROLE_APPLICATION: 사용자가 직접 등록한 애플리케이션 빈
- ROLE_INFRASTRUCTURE: 스프링이 내부에서 사용하는 빈

- `NoSuchBeanDefinitionException`: 존재하지 않는 스프링 빈 이름으로 조회하는 경우
- `NoUniqueBeanDefinitionException`: 타입으로 조회할 때 둘 이상 같은 타입이 있는 경우, 중복 오류 발생 ← 위 에러 클래스 상속받아 선언
	- No qualifying bean of type 'hello.core.member.MemberRepository' available: expected single matching bean but found 2: memberRepository1,memberRepository2

- 부모 타입 조회 → 자식 타입도 함께 조회
# java 객체의 모든 타입은 Object다

# BeanFactory
- 스프링 컨테이너의 최상위 인터페이스 → 스프링 빈 관리 및 조회

# ApplicatinoContext
- BeanFactory 모두 상속받아 사용
- 부가적으로 다음 인터페이스 기능을 포함한다
	- MessageSource: 언어 국제화
	- EnvironmentCapable: 로컬, 개발, 운영 등 분리해서 처리
	- ApplicationEventPublisher: 이벤트 발행 및 구독하는 모델 지원
	- ResourceLoader: 파일, 클래스 path, 외부 등에서 리소스 편리하게 조회

# XML 기반
- 잘 사용하지 않지만.. 알아두는게 좋다

# BeanDefinition
- 스프링의 다양한 형태의 설정 정보, 빈 정보 자체를 추상화 → 역할/구현을 개념적으로 나눔

```bash
beanDefinitionName = memberService beanDefinition = Root bean: class=null; scope=; abstract=false; lazyInit=null; autowireMode=3; dependencyCheck=0; autowireCandidate=true; primary=false; fallback=false; factoryBeanName=appConfig; factoryMethodName=memberService; initMethodNames=null; destroyMethodNames=[(inferred)]; defined in hello.core.AppConfig
```
- 직접적으로 definition 건들 일이 별로 없다
- AppConfig는 팩토리 메서드로 제공한다 