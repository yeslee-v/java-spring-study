# 배열 값 비교
- 배열 길이 = 2, 단순 두 값 비교 → [`Math.max()`](https://www.tcpschool.com/java/java_api_math)
- 배열 길이 가변적 → Stream API
```java
int[] arr = {3, 5, 1, 7};
int maxValue = Arrays.stream(arr)
        .max()
        .getAsInt();
```

## getAsInt()
- https://docs.oracle.com/javase/10/docs/api/java/util/OptionalInt.html#getAsInt()
- OptionalInt 객체에서 int 타입으로 값 꺼내는 메서드
- `Arrays.stream(arr).max()`: `OptionalInt` 반환 → 값이 없을 수도 있다
- 값 없으면 `NoSuchElementException` 반환
	- `orElse()`: 값 없으면 0 반환(좀 더 안전)
	- `orElseThrow()`: custom exception 던질 수 있음

### 그러면 Stream API의 반환값은 무조건 Optional인가?
- No
- 값이 없을 수도 있는 특정 연산에서만 반환 → 안정성을 높인다
	- `findFirst()`, `findAny()`, `max()`, `min()`
# int vs Integer
## int
- 기본 자료형(primitive type) → 스택 메모리에 직접 값 저장
## Integer
- int의 wrapper class → 기본형 데이터를 객체로 변환
- `null` 값 저장 가능
- collection framework: Object 기반 → 기본 자료형을 직접 저장할 수 없다
	- collection: 여러 객체(data) 모아놓은 것 → List, Set, Map등
```java
ArrayList<int> // X
ArrayList<Integer> // O
```

### 그러면 int[]와 Integer[] 차이는?
- int[]: 기본형 배열 → int형 데이터 값 저장하기 위해 메모리 할당 → 성능/메모리 효율 굿
- Integer[]: 참조형 배열 → 배열 값이 null인 경우 → 객체 지향 설계 가능
- Java는 C, C++ 영향받아 배열을 기본형으로 직접 생성할 수 있도록 설계되었음
```java
Integer[] a = { 1, 2, 3, null, 5 };
// Integer[] a = new Integer[]{ 1, 2, 3, null, 5 }; 와 동일

for (Integer num : a) {
	System.out.println(num); // 1 2 3 null 5
}
```

# Auto boxing vs Auto unboxing
- auto boxing: int → Integer
- auto unboxing: Integer → int
- 오버헤드 발생 가능성 있음 → 대량 데이터 처리할 때 int 사용 권장