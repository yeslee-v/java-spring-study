#project 
# discord에 알림봇 추가
- 이유: 스크럼 시간 맨날 까먹는다 → 평일 오전 10시에 디스코드에 스크럼 알람 전송
- https://velog.io/@yundori97/%EB%94%94%EC%8A%A4%EC%BD%94%EB%93%9C-%EC%95%8C%EB%A6%BC%EB%B4%87-%EB%A7%8C%EB%93%A4%EA%B8%B0
- 크론잡 모니터링 툴: https://cronitor.io/cron-job-monitoring?utm_source=crontabguru&utm_campaign=cronitor_logo → 여기엔 단순 알람 전송 용이라 붙이지는 않음

# 코테 시간복잡도에 대해..

## 시간 복잡도란 무엇인가요?
    
- 주어진 문제를 해결하기 위해 필요한 **연산 횟수**
- 일반적으로 프로그램에서 약 **1억 번의 연산은 1초 정도의 시간**이 걸린다고 생각합니다. 따라서 문제에 시간 제한이 2초로 주어져 있다면, 약 2억 번의 연산 안에 답이 나와야 합니다.

## 시간 복잡도는 왜 중요한가요?
    
- **알고리즘 선택의 기준**이 되기 때문입니다.
- 코딩 테스트에서는 다양한 테스트 케이스가 주어지며, 모든 테스트 케이스를 통과해야 합격으로 판단하기 때문에, 항상 **가장 최악의 경우를 염두에 두어야** 합니다.

## 시간 복잡도를 정의하는 세 가지 유형
    
- **빅 오메가 (Big Omega, Ω)**: 최선일 때를 의미합니다. 예를 들어, 탐색 시 찾고자 하는 값이 배열의 첫 번째에 있는 경우를 들 수 있습니다.
    - **빅 세타 (Big Theta, Θ)**: 평균일 때를 의미합니다. 예를 들어, 탐색 시 찾고자 하는 값이 배열의 중간 정도에 있는 경우를 들 수 있습니다.
    - **빅 O (Big O, O)**: **최악일 때를 의미하며, 코딩 테스트에서 기준으로 삼는 표기법입니다.** 예를 들어, 탐색 시 찾고자 하는 값이 배열의 마지막에 있는 경우를 들 수 있습니다.

## 다양한 빅 O 표기법과 수행 속도
    
- **O(1)**: 상수 시간. 데이터 크기와 상관없이 연산 횟수가 일정합니다 (매우 빠름). 실제로는 이런 알고리즘은 거의 없다고 합니다.
- **O(log N)**: 로그 시간. 데이터 크기가 커져도 연산 횟수 증가폭이 매우 작아 빠릅니다. 예를 들어, N이 100일 때 약 7번의 연산으로 답을 찾을 수 있습니다. 이진 탐색(Binary Search)이 대표적입니다.
- **O(N)**: 선형 시간. 데이터 크기(N)에 비례하여 연산 횟수가 증가합니다.
- **O(N log N)**: N 로그 N 시간. N에 비해 완만하게 증가합니다. 병합 정렬(Merge Sort) 등이 여기에 해당합니다.
- **O(N^2)**: N 제곱 시간. 데이터 크기의 제곱에 비례하여 연산 횟수가 증가하여 데이터가 커지면 급격히 느려집니다. 버블 정렬(Bubble Sort) 등이 여기에 해당합니다.
- **O(2^N)**: 2의 N승 시간. 지수적으로 연산 횟수가 증가하여 매우 느립니다.
- **O(N!)**: N 팩토리얼 시간. 데이터가 커지면 기하급수적으로 시간이 오래 걸립니다 (가장 느림).

## 코딩 테스트에서 시간 복잡도 활용 방법
    
### 올바른 알고리즘 선택 기준
- 항상 **데이터의 개수와 제한 시간을 확인**해야 합니다.
- 예시: N이 100만 개이고 제한 시간이 2초인 정렬 문제의 경우.
	- 2초는 약 2억 번의 연산 이내에 해결해야 합니다.
	- 버블 정렬 (O(N^2)) 사용 시: 100만^2 = 1조 번의 연산으로 2억 번보다 훨씬 많아 **시간 초과**가 발생합니다.
	- 병합 정렬 (O(N log N)) 사용 시: 100만 * log(100만) ≈ 100만 * 20 = 2천만 번의 연산으로 2억 번보다 훨씬 적어 **통과**할 수 있습니다.
- 따라서 데이터의 크기에 맞춰 적합한 시간 복잡도를 가진 알고리즘을 선택하는 것이 중요합니다.
1. **내 코드의 효율성 분석**:
        - **상수는 시간 복잡도 계산에서 제외**합니다. 예를 들어, `O(3N)`은 `O(N)`으로 간주합니다. 상수는 프로그래밍에서 큰 영향도를 발휘하지 않기 때문입니다.
        - **가장 많이 중첩된 반복문(중첩문)의 수행 횟수가 시간 복잡도의 기준이 됩니다.** 예를 들어, 2중 포문은 O(N^2)의 시간 복잡도를 가지며, 이는 단일 포문이 아무리 많아도 2중 포문보다 크지 않습니다. 3중 포문이 있다면 3중 포문이 가장 큰 영향을 미칩니다.
        - 코딩 테스트에서 **시간 초과**가 발생했을 때, 내가 짠 로직이 효율적인지 이 기준들을 바탕으로 분석하여 비효율적인 부분을 찾아 수정함으로써 문제를 해결할 수 있습니다.

# 코테 전략

**“문제를 푼다” → “익힌다”로 바꾸는 게 핵심**이고, 매일 1문제씩 푸는 스터디 환경은 그걸 뿌리내릴 수 있는 최적 조건이야.

  

냉정하게 말하면,

**“하루 1문제만 푼다”는 절대 실력이 안 는다.**

**“1문제를 가지고 세 번 이상 푼다”가 실력 만든다.**

---

## **✅ 실력을 완전히 익히는 3단계 학습 루틴**

  

하루 1문제를 기준으로, **아래 3단계 루틴을 매일 반복해.**

---

### **1단계: 직접 고민해서 푼다 (최대 30분~40분)**

- 무조건 손으로 짜봐. 시간이 오래 걸려도 **AI 안 보고 짜야 함.**
    
- **못 풀어도 절대 부끄러운 게 아님.** 패턴을 머릿속에서 끌어내는 게 목적이야.
    
- 못 풀었다면 어디까지 접근했는지, 어디서 막혔는지 구체적으로 적어둬.
    

```
ex) 인접 노드는 떠올렸는데 방문 처리에서 막혔다 / 시간 초과가 왜 나는지 몰랐다
```

---

### **2단계: 풀이 확인 후 다시** 

### **손코딩으로 재현**

###  **(이게 핵심)**

- 해설을 보고 이해했다면, **코드 닫고 손으로 다시 처음부터 구현**
    
- 이 과정을 **한 번이라도 건너뛰면 기억에 안 남는다**
    
- 여유되면 입력 예제 없이도 설명하면서 푸는 연습 해봐 (자기 입으로 알고리즘 설명)
    

---

### **3단계: 유사 문제 1~2개 더 풀기 (다른 날 해도 됨)**

- **이건 하루에 다 안 해도 돼.** 대신 주말에 몰아서라도 유사 유형은 최소 2문제 더 풀어야 진짜 패턴이 머리에 남아.
    
- 백준에 태그 걸려있는 문제, solved.ac 분류 추천.
    

```
ex) 오늘 ‘토마토 BFS’ 풀었으면 → ‘미로 탐색’, ‘유기농 배추’도 풀어보기
```

---

## **✅ 덤: 복습 루틴 만들기 (10분만 투자하면 충분함)**

- 매일 or 주 2회, “내가 못 풀었거나 헷갈렸던 문제” 리스트 복습
    
- 방법:
    
    - **풀이 안 보고 손코딩 다시 해보기**
        
    - **문제만 읽고 핵심 알고리즘 말해보기**
        
    

  

이걸 반복하면 **문제를 보자마자 “이건 그거네”** 라고 입 밖에 나오는 시점이 옴. 그때가 골드권 진입 시기임.

---

## **✅ 정리: “하루 1문제”를 진짜 실력으로 만드는 방법**

|**단계**|**내용**|**목적**|
|---|---|---|
|1단계|직접 풀기 (30분 한정)|사고 회로 훈련|
|2단계|해설 보고 재구현|패턴 저장 & 재현력|
|3단계|유사 문제 풀기|패턴 일반화|
|복습|주간 누적 복습 (손코딩 or 개념 말하기)|장기 기억화|

---

## **🔥 마지막으로**

- 이 루틴을 3주만 하면, 지금 너 스스로도 놀랄 만큼 실력이 붙는다.
    
- **핵심은 “한 문제에 오래 머무는 것”**이야.
    
- 많이 푸는 게 아니라, **깊이 푸는 것.**
  