---
sticker: lucide//bean
tags:
  - spring/bean
---
# 조회 대상 Bean이 2개 이상일 때
- `@Autowired()`: 필드명(타입) 매칭
- `@Quilifier`: 추가 구분자 붙여줌 → `@Quilifier`끼리 매칭(상세하게 동작)
- `@Primary`: 우선순위 정해줌(기본값처럼 동작)
## 의존성 해결 우선순위
- `@Quilifier` - `@Primary` - 필드/파라미터명 매칭
- annotation은 상속이 아니다.

# 조회할 Bean이 모두 필요할 때: List, Map
- 특정 타입의 모든 Spring Bean들을 한번에 주입받을 수 있다
- 클래스명의 첫 글자를 소문자로 바꿔서 빈 이름을 만든다

---
# interface vs @interface
- 추상화 클래스 선언 vs `annotation` 타입 정의

---
# Rotate Array

```java
public void rotate(int[] nums, int k) {
	int cnt = 0;
	int tmp = 0;
	int numsLen = nums.length;	
	int[] newNums = new int[numsLen + 1];
	
	for (int i = 0; i < k; i++) {
		tmp = nums[numsLen - 1];
		newNums[0] = tmp;
		
		System.arraycopy(nums, 0, newNums, 1, numsLen);
	}
	
	for (int i = 0; i < numsLen; i++) {
		nums[i] = newNums[i];
	}
}
```
- 문제: 첫번째 iteration에서 `nums`가 업데이트되지 않는다.
- `System.arraycopy(source_arr, sourcePos, dest_arr, destPos, len);`

## 1번째 시도
```java
import java.lang.System;

class Solution {
	public void rotate(int[] nums, int k) {
		int numsLen = nums.length;
		int[] tmp = new int[numsLen];
		
		for (int i = 0; i < numsLen; i++) {
			tmp[(i + k) % numsLen] = nums[i]; // 핵심 로직!
		}
		
		System.arraycopy(tmp, 0, nums, 0, numsLen);
	}
}
```
- 2ms 나옴 → **Could you do it in-place with `O(1)` extra space?**
## 2번째 시도
```java
class Solution {
	public void rotate(int[] nums, int k) {
	
		int len = nums.length, tmp = 0, i = 0;
		k = k % len; // Index 1 out of bounds for length 1
		
		if (k == 0 || len == k) return ;

		// 전체 reverse
		for (i = 0; i < (len / 2); i++) {
			tmp = nums[i];
			nums[i] = nums[len - i - 1];
			nums[len - i - 1] = tmp;
		
		}

		// k만큼 다시 뒤집기
		for (i = 0; i < (k / 2); i++) {
			tmp = nums[i];
			nums[i] = nums[k - i - 1];
			nums[k - i - 1] = tmp;
		}

		// 나머지 뒤집기
		for (i = 0; i < ((len - k) / 2); i++) {
			tmp = nums[k + i];
			nums[k + i] = nums[len - 1 - i];
			nums[len - 1 - i] = tmp;
		}
	}
}
```
- 연산이 많아서 그런가 오히려 3ms로 늘었다. 0ms는 어떤 케이스일까?