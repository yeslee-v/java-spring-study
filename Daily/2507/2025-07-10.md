#ps/hashSet 
# 128. Longest Consecutive Sequence
## 1차 시도: O(nlogn)
- You must write an algorithm that runs in `O(n)` time. 위배
```java
import java.util.Arrays;

class Solution {
	public int longestConsecutive(int[] nums) {
		int len = nums.length;
		
		if (len == 0) {
			return 0;
		}

		// O(nlogn)
		int[] sortedNums = Arrays.stream(nums).distinct().sorted().toArray();
		
		int start = sortedNums[0];
		int cnt = 0;
		int max = 0;
		for (int i = 0; i < sortedNums.length;) {
			if (start == sortedNums[i]) {
				cnt++;
				start++;
				i++;
			} else {
				start = sortedNums[i];
				cnt = 0;
			}
			
			max = Math.max(max, cnt);
		}
		
		return max;
	}
}
```
## 2차 시도: HashSet 사용 → O(n)
- 정렬없이 O(n)을 만드려면?
- **특정 숫자 존재 여부 확인** → HashSet의 `contains`: `O(1)` → 해시 함수로 위치 계산
```java
import java.util.HashSet;

class Solution {
	public int longestConsecutive(int[] nums) {
		int len = nums.length;
		
		if (len == 0) {
			return 0;
		}
		
		HashSet<Integer> hash = new HashSet<Integer>();
		
		int max = 0;
		int cnt = 0;
		int start = 0;
		for (int i = 0; i < len; i++) {
			hash.add(nums[i]);
		}
		
		for (int h: hash) {
			if (!hash.contains(h - 1)) { // h가 시작점인지 확인
				cnt = 0;
				start = h;

				// while 문은 시간복잡도 포함 대상 아님
				// for문에서 시작점 체크 후 각 숫자는 while 문에서 한 번만 체크함
				while (hash.contains(start)) {
					cnt++;
					start++;
				}
				
				max = Math.max(max, cnt);
			}
		}
		
		return max;
	}
}
```