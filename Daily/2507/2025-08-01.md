#ps/tree #ps/dfs
# DFS(깊이 우선 탐색)
- 그래프 완전 탐색 기법 중 하나
	- 시작 노드 출발 - **한 쪽 분기 정해 최대 깊이까지 탐색** - 다른 쪽 분기로 이동
## 특징
- **재귀 함수** 구현: stack overflow 유의
- 스택 자료구조 이용(FILO)
- O(V + E): V node, E edge
- 단절점 찾기, 단절선 찾기, 사이클 찾기, 위상 정렬

## 핵심 이론
- **한 번 방문한 노드를 다시 방문하지 않는다** → 노드 방문 여부 체크할 배열 필요
- 그래프는 인접 리스트로 표현
- LIFO
## 방법
1. DFS 시작 노드 정하고 사용할 자료구조 초기화
	1. 스택 자료 구조에 시작점 더하기
2. 스택에서 노드 꺼낸 후, 꺼낸 노드의 인접 노드를 다시 스택에 삽입
	1. 스택에서 노드 꺼내면서 탐색 순서에 꺼낸 노드 기록
	2. 대상 노드의 인접 노드 스택에 삽입: 순서 상관 없음
	3. 노드를 삽입하여 방문 배열 체크
3. 스택 자료구조에 값이 없을 때까지 반복
	1. 이미 다녀간 노드는 방문 배열 바탕으로 재삽입하지 않는다

# Tree
- node, edge로 연결된 그래프의 특수 형태
## 특징 
- 순환 구조 가지지 않고 1개 루트노드 존재
- 루트노드 제외한 노드는 단 1개의 루트 노드 가짐
- 부분 트리 또한 트리 모든 특징 따른다
- 트리에서 임의의 두 노드를 이어주는 경로는 유일하다
## 구성요소
- node: index, value 표현
- edge: 노드 - 노드 연결 관계 나타내는 선
- root node, parent node, child node
- leaf node, sub tree
## 코테에서의 tree
1. graph를 푸는 tree: node, edge → 인접리스트로 표현
	1. **DFS, BFS**
2. tree만을 위한 문제 → 일차원 배열로 표현
	1. 이진트리
	2. **세그먼트 트리**, LCA

# 이진 트리(Binary Tree)
- 각 노드의 자식 노드(차수)의 개수가 2 이하로 구성된 트리
- 종류: 편향 이진 트리, 포화 이진 트리, 완전 이진 트리
## 이진 트리의 순차 표현
- 트리 자료구조: 배열
- **배열 - 인덱스 간의 상관 관계**
	- 루트노드: index = 1
	- 부모노드: index = index / 2
	- 왼쪽 자식 노드: index = index * 2
	- 오른쪽 자식 노드: index = index * 2 + 1

---
# [100. Same Tree](https://leetcode.com/problems/same-tree/)
- while 문으로 풀으려고 했으나 loop 조건을 못세워서 tree 순회를 못하고 있었다
- claude가 재귀라는 키워드를 줬음에도 이해를 못해서 답변을 봤는데도 이해가 잘 안가서.. 강의보고 왔다.
- 그러고 다시 해설을 보니 왜 stack을 사용하는지 이해가 갔다.